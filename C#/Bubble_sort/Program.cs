/* 
Элемент0 Элемент1 Элемент2 Элемент3 Элемент4 Элемент5
Берём 2 элемента, сравниваем их между собой (к примеру элемент0 и элемент1), если элемент0 > элемент1, то меняем их местами
Элемент1 Элемент0 Элемент2 Элемент3 Элемент4 Элемент5
На следующей итерации сравниваем следующую пару (элемент0 и элемент2), если элемент0 > элемент2, то меняем местами
Элемент1 Элемент2 Элемент0 Элемент3 Элемент4 Элемент5
На следующей итерации сравниваем следующую пару (элемент0 и элемент3), если элемент0 < элемент2, то оставляем, как есть
Элемент1 Элемент2 Элемент0 Элемент3 Элемент4 Элемент5
На следующей итерации сравниваем следующую пару (элемент3 и элемент4), если элемент3 > элемент4, то меняем местами
Элемент1 Элемент2 Элемент0 Элемент4 Элемент3 Элемент5
и т.д.
Сложность алгоритма - O(n^2)
-----------------------------------------------------------------------------------------------------------------------------
Сколько мы будем делать действий, имея некоторое кол-во элементов?
P.s.: Примеры в скобках для замены одного элемента, через тире пишем кол-во действий для всех элементов в массиве

Кол-во элементов:   1
Сложность действий: n(1) - действий не потребовалось, массив уже отвортирован

Кол-во элементов:   2
Сложность действий: n(2 1) - 1 действие

Кол-во элементов:   3
Сложность действий: n(3 2 1 -> 2 1 3 -> 1 2 3) - 9 действия

Кол-во элементов:   4
Сложность действий: n(4 3 2 1 -> 3 2 1 4 -> 2 1 3 4 -> 1 2 3 4) - 16 действий
*/
using System.Diagnostics;


bool Check(int[] array) // Пропишем метод, чтобы просматривать, все ли значения отсортированы от min до max
{
    int size = array.Length;

    for (int i = 0; i < size; i += 1)
    {
        if (array[i] > array[i + 1]) 
        {
            return false;
        }
    }
    return true;
}


int n = 10;
int max = 100;
int[] array = new int[n];


for (int i = 0; i < array.Length; i += 1)
{
    array[i] = Random.Shared.Next(max);
}

int[] arr1 = new int[n];
int[] arr2 = new int[n];
Array.Copy(array, arr1, n);
Array.Copy(array, arr2, n);

Stopwatch sw = new Stopwatch();
sw.Start();

for (int k = 0; k < n - 1; k += 1) // Сложность сортировки пузырком, просто добавив int k, теперь стала O((n^2)/2)
{
    for (int i = 0; i < n - 1 - k; i += 1) // ставим i < n - 1 - k, чтобы не просматривать последнее значение, ибо оно бессмысленно
    {
        if (arr1[i] > arr1[i+1])
        {
            int temp = arr1[i];
            arr1[i] = arr1[i+1];
            arr1[i+1] = temp;
        }
    }
}

sw.Stop();


Console.WriteLine($"arr1 - {Check(arr1)} {sw.ElapsedMilliseconds}ms");

sw.Reset();
sw.Start();

for (int i = 0; i < n - 1; i += 1)
{
    if (arr2[i] > arr2[i+1])
    {
        int temp = arr2[i];
        arr2[i] = arr2[i+1];
        arr2[i+1] = temp;
    }
}

sw.Stop();

Console.WriteLine($"arr2 - {Check(arr2)} {sw.ElapsedMilliseconds}ms");

/* Оценка сложности операции:

int i = 12;
i += 1; // мы считаем за O(1)

По факту происходят следубщие действия:
В памяти есть переменная i равная 12 (в двоичном представлении)
Мы находим переменную в памяти
Выделяем временную ячейку в памяти, в которой проводим вычисление (в ней содержится 12 + 1 = 13)
Возвращаем значение 13 в ячейку памяти переменной 

Таким образом, выделение памяти - 1 дейтсвие, чтение данных - 2 действия, сложение - 3 действия, запись во временную
часть памяти - 4 действия, копирование из временной ячейки в ячейку i - 5 действий

Для конструкции
i = 0
while (i < n);

Чтение данных i происходит n раз
Чтение данных n происходит n раз
Выполнение операции по отношению к двум числам происходит n раз
+ 5 действий выше
И тогда 3n * 5 = 15n
Сложность операции мы считаем O(n), а не O(15n), ибо
цифровое значение обычно отбрасывается (при процентах погрешности менее 5%)

В итоге на больших числах цифровые значения отбрасываются, ибо на нашем примере при входных данных n = 1 000 000
погрешность составляет 0,002%, а делать оценку на малых числах не имеет значения, ибо они и так хорошо работают
(при условии, что мы не считаем факториал, функцию Аккермана и т.п.)
*/